--- a/lib/file/fileLockPrimitive.c
+++ b/lib/file/fileLockPrimitive.c
@@ -60,8 +60,8 @@
 #define LOGLEVEL_MODULE main
 #include "loglevel_user.h"
 
-#define LOCK_SHARED     "S"
-#define LOCK_EXCLUSIVE  "X"
+#define LOCK_SHARED_S     "S"
+#define LOCK_EXCLUSIVE_X  "X"
 #define FILELOCK_PROGRESS_DEARTH 8000 // Dearth of progress time in msec
 #define FILELOCK_PROGRESS_SAMPLE 200  // Progress sampling time in msec
 
@@ -472,8 +472,8 @@ fixedUp:
       goto corrupt;
    }
 
-   if ((strcmp(argv[3], LOCK_SHARED) != 0) &&
-       (strcmp(argv[3], LOCK_EXCLUSIVE) != 0)) {
+   if ((strcmp(argv[3], LOCK_SHARED_S) != 0) &&
+       (strcmp(argv[3], LOCK_EXCLUSIVE_X) != 0)) {
       goto corrupt;
    }
 
@@ -1096,8 +1096,8 @@ FileLockWaitForPossession(const char *lockDir,       // IN:
        ((memberValues->lamportNumber == myValues->lamportNumber) &&
           (Unicode_Compare(memberValues->memberName,
                            myValues->memberName) < 0))) &&
-        ((strcmp(memberValues->lockType, LOCK_EXCLUSIVE) == 0) ||
-         (strcmp(myValues->lockType, LOCK_EXCLUSIVE) == 0))) {
+        ((strcmp(memberValues->lockType, LOCK_EXCLUSIVE_X) == 0) ||
+         (strcmp(myValues->lockType, LOCK_EXCLUSIVE_X) == 0))) {
       char *path;
       uint32 loopCount;
       Bool   thisMachine;
@@ -1675,7 +1675,7 @@ FileLockIntrinsicPortable(const char *pathName,   // IN:
           */
 
          Warning(LGPFX" %s implicit %s lock succeeded on '%s'.\n",
-                 __FUNCTION__, LOCK_SHARED, pathName);
+                 __FUNCTION__, LOCK_SHARED_S, pathName);
 
          *err = 0;
          memberFilePath = &implicitReadToken;
@@ -1838,7 +1838,7 @@ FileLockIntrinsic(const char *pathName,    // IN:
    /* Construct the locking directory path */
    lockBase = Unicode_Append(pathName, FILELOCK_SUFFIX);
 
-   myValues.lockType = exclusivity ? LOCK_EXCLUSIVE : LOCK_SHARED;
+   myValues.lockType = exclusivity ? LOCK_EXCLUSIVE_X : LOCK_SHARED_S;
    myValues.exclusivity = exclusivity;
    myValues.waitTime = 0;
    myValues.msecMaxWaitTime = msecMaxWaitTime;
-- 
2.1.4

